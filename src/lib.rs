//! # lorri
//! lorri is a wrapper over Nix to abstract project-specific build
//! configuration and patterns in to a declarative configuration.

#![warn(missing_docs)]

#[macro_use]
extern crate structopt;

#[macro_use]
extern crate log;
extern crate env_logger;

extern crate regex;
#[macro_use]
extern crate lazy_static;

extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;

extern crate futures;
extern crate notify;
extern crate tempfile;
extern crate vec1;

extern crate proptest;

pub mod bash;
pub mod build_loop;
pub mod builder;
pub mod cas;
pub mod changelog;
pub mod cli;
pub mod constants;
pub mod daemon;
pub mod locate_file;
pub mod logging;
pub mod mpsc;
pub mod nix;
pub mod ops;
pub mod osstrlines;
pub mod pathreduction;
pub mod project;
pub mod socket;
pub mod thread;
pub mod watch;

use std::path::{Path, PathBuf};
use std::convert::TryFrom;

// OUT_DIR and build_rev.rs are generated by cargo, see ../build.rs
include!(concat!(env!("OUT_DIR"), "/build_rev.rs"));

/// A .nix file.
#[derive(Hash, PartialEq, Eq, Clone, Debug, Serialize, Deserialize)]
pub struct NixFile {
    p: PathBuf,
}

impl NixFile {
    /// Underlying `&OsStr`.
    pub fn as_os_str(&self) -> &std::ffi::OsStr {
        self.p.as_os_str()
    }
}

/// Proxy through the `Display` class for `PathBuf`.
impl std::fmt::Display for NixFile {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.p.display().fmt(f)
    }
}

pub(crate) fn try_nixfile_from_os_str(s: &std::ffi::OsStr) -> Result<NixFile,std::ffi::OsString> {
    NixFile::try_from(s)
        .map_err(|e| std::ffi::OsString::from(e.to_string()))
}

impl std::convert::TryFrom<&std::ffi::OsStr> for NixFile {
    type Error = std::io::Error;

    fn try_from(s: &std::ffi::OsStr) -> Result<NixFile,Self::Error> {
        Self::try_from(PathBuf::from(s.to_owned()))
    }
}

impl std::convert::TryFrom<PathBuf> for NixFile {
    type Error = std::io::Error;

    fn try_from(p: PathBuf) -> Result<NixFile,Self::Error> {
        p.canonicalize().map(|p| NixFile { p })
    }
}

impl From<NixFile> for PathBuf {
    fn from(p: NixFile) -> PathBuf {
        p.p
    }
}

impl std::convert::AsRef<Path> for NixFile {
    fn as_ref(&self) -> &Path {
        self.p.as_ref()
    }
}

/// A .drv file (generated by `nix-instantiate`).
#[derive(Hash, PartialEq, Eq, Clone, Debug)]
pub struct DrvFile(PathBuf);

impl DrvFile {
    /// Underlying `Path`.
    pub fn as_path(&self) -> &Path {
        self.0.as_ref()
    }
}

impl From<PathBuf> for DrvFile {
    fn from(p: PathBuf) -> DrvFile {
        DrvFile(p)
    }
}
